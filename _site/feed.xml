<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://jihwankim.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jihwankim.github.io/" rel="alternate" type="text/html" /><updated>2021-04-15T21:33:15+09:00</updated><id>https://jihwankim.github.io/feed.xml</id><title type="html">JihwanKim Develop Blog</title><subtitle>백엔드 개발자이며, 취미로 플러터, 유니티를 만지는 개발자</subtitle><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><entry><title type="html">Auth와 User 분리</title><link href="https://jihwankim.github.io/thinking/Auth%EC%99%80-User-%EB%B6%84%EB%A6%AC/" rel="alternate" type="text/html" title="Auth와 User 분리" /><published>2021-04-15T00:00:00+09:00</published><updated>2021-04-10T22:06:00+09:00</updated><id>https://jihwankim.github.io/thinking/Auth%EC%99%80-User-%EB%B6%84%EB%A6%AC</id><content type="html" xml:base="https://jihwankim.github.io/thinking/Auth%EC%99%80-User-%EB%B6%84%EB%A6%AC/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;하나의 유저 계정에 여러 로그인 방법 추가 설계 고민&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;요즘은 OAuth2를 이용하여 회원가입/로그인하는 서비스들이 매우 많아졌다.&lt;br /&gt;
해당 방법으로 로그인을 하다 보면, 동일한 계정에 대해 구글계정으로 로그인 등 여러가지 추가 로그인 방법이 있으면 좋겠다고 생각이 들 때가 있고, 기존에 사용하던 연동된 계정을 사용하지 않게 되는 경우도 발생한다.&lt;br /&gt;
따라서, 하나의 유저 계정에 여러개의 인증 방법으로 로그인 할 수 있는 방법에 대해 고민해보았고, 어떻게 해야할 지에 대해 기록한다.&lt;/p&gt;

&lt;p&gt;내가 지금까지 만들었던 DB의 대부분은 유저정보가 곧 로그인 정보와 동일하였다.&lt;br /&gt;
만약, 로그인을 이메일(아이디)/비밀번호로 사용하다가 OAuth2와 같은 로그인 방법이 추가되면, 테이블 구조와 코드가 더러워졌었다.&lt;br /&gt;
하지만, 해당 방법 말고 유저 테이블과 로그인에 필요한 인증 테이블을 다르게 가지고 간다면, 해당 문제가 발생하지 않겠다라고 생각이 들었다.&lt;/p&gt;

&lt;p&gt;해당 방법은 이전에 회사에서 퇴사하신 분과 토이프로젝트 작업을 할 때, 고민하다가 적용하였었다.&lt;br /&gt;
테이블 구조는 아래와 같이 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/image/auth_user_seperate/table_structure.png&quot; alt=&quot;table_structure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 이미지는 대략적으로 이런식으로 구현할 거라는 것만 그렸다.&lt;br /&gt;
만약, 제공자가 구글인 인증방법이 추가된다면, 테이블을 하나 추가 시키면 된다.&lt;br /&gt;
그리고 로그인 시, 입력되는 type에 따라, 인증방법을 달리하면 된다.&lt;/p&gt;

&lt;p&gt;만약, 회원가입/로그인/인증코드 추가 Erlang 코드상에서 나타낸다면, 아래와 같은 코드가 나올 것이다.&lt;br /&gt;
단, 예제를 위해 작성 하였고, 에러에 대한 대비 코드는 추가하지 않았다. 실제 코드를 실행해보지 않았다.&lt;br /&gt;
실제로 작업한다면, 함수합성을 사용할 것이다.&lt;/p&gt;
&lt;h3 id=&quot;autherl&quot;&gt;auth.erl&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Erlang&quot;&gt;  ...
  -export_all().

  -spec sign_up(bitstring(), types:auth_type(), map()) -&amp;gt; 
    {ok, map()} 
    | {error, already_exist_auth_for_email}
    | {error, already_use_email}.
  sign_up(Name, Type, AuthData)-&amp;gt;
    {ok, UserInfo} = model_user:insert(Name),
    {ok, AuthModule} = auth_plugin_utils:type_to_auth_module(Type),

    {ok, _} = AuthModule:new(UserInfo, AuthData),
    {ok, UserInfo}.

  -spec sign_in(types:auth_type(), map())-&amp;gt;
    {ok, map()}
    | {erorr, invalid_auth_info}.
  sign_in(Type, AuthData)-&amp;gt;
    {ok, AuthModule} = auth_plugin_utils:type_to_auth_module(Type),
    case
      AuthModule:get(Type, AuthData)
    of
      {ok, UserIdx}-&amp;gt;
        {ok, UserInfo} = model_user:get_by_user_idx(UserIdx),
        {ok, UserInfo};
      {error, _} = Err-&amp;gt;
        Err
    end.
  
  -spec add_auth(pos_integer(), types:auth_type(), map())-&amp;gt;
    ok
    | {error, already_exist_auth_for_email}
    | {error, already_use_email}.
  add_auth(UserIdx, Type, AuthData)-&amp;gt;
    {ok, UserInfo} = model_user:get_by_user_idx(UesrIdx),
    {ok, AuthModule} = auth_plugin_utils:type_to_auth_module(Type),

    case
      AuthModule:new(UserInfo, AuthData)
    of
      {ok, _} -&amp;gt;
        ok;
      {error, _} = Err-&amp;gt;
        Err
    end.

    -spec withdraw(pos_integer()) -&amp;gt; ok.
    withdraw(UserIdx)-&amp;gt;
      {ok, UserInfo} = model_user:get_by_user_idx(UesrIdx),
        [
          AuthModule:remove(UserInfo)
          || AuthModule &amp;lt;- auth_plugin:get_all_auth_modules()],
      model_user:delete_by_user_idx(UserIdx),
      ok.

  %%%
  %%% Internal Function
  %%%

  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;auth_plugin_for_emailerl&quot;&gt;auth_plugin_for_email.erl&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Erlang&quot;&gt;
  -behavior(auth_plugin).
  -export_all().
  
  -spec new(UserInfo :: map(), AuthData :: map()) -&amp;gt; 
    {ok, map()}
    | {error, already_exist_auth_for_email}
    | {error, already_use_email}.
  new(#{uesr_idx := UesrIdx} = UserInfo, #{email := Email, password := Password} = _AuthData)-&amp;gt;
    IsAlreadyHasAuth = 
      case
        model_auth_for_email:get_by_user_idx(UserIdx)
      of
        {ok, _}-&amp;gt;
          true;
        {error, _}-&amp;gt;
          false
      end,
    
    IsAlreadyUseEmail = 
      case
        model_auth_for_email:get_by_email(Email)
      of
        {ok, _}-&amp;gt;
          true;
        {error, _}-&amp;gt;
          false
      end,
      
    case
      {
        IsAlreadyHasAuth
        , IsAlreadyUseEmail
      }
    of
      {true, _} -&amp;gt;
        {error, already_exist_auth_for_email};
      {_, true} -&amp;gt;
        {error, already_use_email};
      {false, false} -&amp;gt;
        % 패스워드 암호화 과정 코드가 포함되어야 하지만, 여기에는 포함하지 않음.
        model_auth_for_email:insert(UserIdx, Email, Password)
    end.

  -spec get(AuthData :: map()) -&amp;gt; 
    {ok, pos_integer()}
    | {error, invalid_auth_info}.
  get(#{email := Email, password := Password} = _AuthData) -&amp;gt;
    case
      model_auth_for_email:get_by_email(Email)
    of
      {ok, AuthInfo} -&amp;gt;
        case
          maps:get(password, AuthInfo)
        of
          Password -&amp;gt; 
            {ok, maps:get(user_idx, AuthInfo)};
          _ -&amp;gt;
            {error, invalid_auth_info}
        end;
      {error, _} -&amp;gt;
        {error, invalid_auth_info}
    end.

  -spec remove(UserInfo :: map()) -&amp;gt; 
    {ok, any()}.
  remove(#{user_idx := UserIdx} = _UserInfo) -&amp;gt;
    model_auth_for_email:remove_by_user_idx(UserIdx).
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;auth_plugin_utilserl&quot;&gt;auth_plugin_utils.erl&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Erlang&quot;&gt;  -export_all().

  type_to_auth_module(email)-&amp;gt;
    {ok, auth_plugin:auth_plugin_for_email()};
  type_to_auth_module(Any)-&amp;gt;
    io:format(&quot;{[ [~p:~p] invalid auth module! ~p ]} ~n&quot;, [?MODULE, ?FUNCTION_NAME, Any]),
    {error, invalid_auth_module}.

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;auth_pluginerl&quot;&gt;auth_plugin.erl&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Erlang&quot;&gt;  -export_all().

  auth_plugin_for_email()-&amp;gt;
    ?FUNCTION_NAME().

  get_all_auth_modules()-&amp;gt;
    [FunctionName || {FunctioName, _Arity}&amp;lt;- module_info(exports), FunctionName =/= module_info, FunctionName =/= get_all_auth_modules].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;behavior는 Java로 치면 Interface같은 역할을 하는데, Erlang에서는 강제성을 띄지 않는다.&lt;br /&gt;
위와 같은 방식을 사용하면, 새로운 로그인/회원가입 방법이 추가되면 아래 순서대로 진행하면 된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;로그인/회원가입 방법에 맞는 테이블 추가&lt;/li&gt;
  &lt;li&gt;로그인/회원가입 방법에 맞는 plugin 파일을 추가 ( ex : auth_plugin_for_kakao)&lt;/li&gt;
  &lt;li&gt;auth_plugin.erl 파일로 가서 해당 모듈명에 해당하는 함수를 추가시킨다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_plugin_utils.erl&lt;/code&gt;파일에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun type_to_auth_module/1&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kakao&lt;/code&gt;에 해당되는 패턴매칭을 추가시켜준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;만약, 특정 방법으로 추가적인 회원가입/로그인을 막게 되면, 해당 plugin 내부에서 new/get function의 return으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{error, not_suppert}&lt;/code&gt; 정도만 주면 될것이라 생각된다.&lt;/p&gt;

&lt;p&gt;실제, 해당 방법이 적용된 프로젝트는 서버는 TypeScript + Express + TypeORM를 사용하였고, 클라이언트는 Flutter를 통해 작성하였다.&lt;br /&gt;
개인적으로 재밌었는데, 서로 바빠지게 되면서, 추가적인 하지 못하게 되어 안타까운 토이 프로젝트였다.&lt;br /&gt;
해당 코드는 추후, 개인 Github를 통해서 올릴 예정이다.&lt;/p&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="Thinking" /><summary type="html">하나의 유저 계정에 여러 로그인 방법 추가 설계 고민</summary></entry><entry><title type="html">Twinny Helper 앱 제작기</title><link href="https://jihwankim.github.io/flutter/Twinny-Helper-%ED%9B%84%EA%B8%B0/" rel="alternate" type="text/html" title="Twinny Helper 앱 제작기" /><published>2021-04-10T00:00:00+09:00</published><updated>2021-04-10T22:06:00+09:00</updated><id>https://jihwankim.github.io/flutter/Twinny-Helper-%ED%9B%84%EA%B8%B0</id><content type="html" xml:base="https://jihwankim.github.io/flutter/Twinny-Helper-%ED%9B%84%EA%B8%B0/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;사내 비즈박스 도입에 따른, TwinnyHelper 앱 제작기&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;총 개발 소요시간 : 약 20시간&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;올해 초, 사내 그룹웨어가 도입되었다.&lt;br /&gt;
도입된 그룹웨어는 비즈박스고, 해당 그룹웨어를 통해서 출퇴근기록, 휴가신청, 회의실예약 등이 가능하다.&lt;/p&gt;

&lt;p&gt;이전에, slack을 이용해서, 출근 기록을 기록하고, 해당 기록을 기반으로 회사 식대를 계산하는 Bot을 만들어서 사용했었는데, 해당 비즈박스의 API들을 사용하여, Bot의 기능을 대체할 수 있겠다고 생각했다.&lt;br /&gt;
해당 그룹웨어에서 자체 제작된 앱이 있으나, 출퇴근기록조회, 휴가신청같은 기능이 앱에서 동작하지 않아서 따로 제작하기로 마음먹었다.&lt;/p&gt;

&lt;p&gt;앱 제작에 사용된 프레임워크는 구글에서 만든 Flutter이다.&lt;br /&gt;
처음 접했을 때는 1.0이 막 런칭되었을 떄부터 조금씩 건드려보고 있는데, UI만드는 부분이 너무 직관적이고, 레고를 조립한다는 느낌을 받았어서 개인적으로 앱 만들기가 편하다고 생각하는 프레임워크다.&lt;/p&gt;

&lt;p&gt;상태관리는 Provider를 사용했다.&lt;br /&gt;
해당 라이브러리는 이전에 여러가지 앱을 만들때부터 사용해봤는데, 사용방법 자체도 간단하고 복잡하지 않아 개인적으로 만족스럽게 사용중이다.&lt;br /&gt;
저장소는 SharedPreference를 사용했고, 유저의 계정 id/password 를 암호화해서 저장하였다.&lt;/p&gt;

&lt;p&gt;일단 비즈박스에 공개된 API 문서부터 찾아보았는데, 해당 문서를 찾지 못했다.&lt;br /&gt;
따라서, 크롬 개발자 도구를 이용해서, 네트워크 통신 내용을 보며, API 정보를 하나 하나 찾아갔다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;로그인&quot;&gt;로그인&lt;/h1&gt;
&lt;p&gt;비즈박스 그룹웨어에서는 클라이언트(웹) 측에서 계정아이디와 비밀번호를 암호화해서 보낸다.&lt;br /&gt;
해당 부분에 대해서 앱 내에서도 따라 구현하였다.&lt;/p&gt;

&lt;p&gt;로그인시, 쿠키발급을 위한 API와, 실제 추가적인 몇가지 권한을 부여하는 API가 따로 존재했다.&lt;br /&gt;
즉, 로그인 API 요청 -&amp;gt; 쿠키발급 -&amp;gt; 권한부여 서버(Spring)로 Redirect -&amp;gt; 메인 페이지 이동 순서로 로그인이 진행되었다.&lt;br /&gt;
만약, 쿠키는 발급받았는데, Spring 서버로 Redirect시키지 않으면 일부 기능이 정상동작하지 않는다.&lt;br /&gt;
(그중, 경험했던 정상동작하지 않는 부분은 자원예약에서 참여자를 지정할 수 있는데, 해당 목록을 불러오지 못하는 부분이 있었다.)&lt;/p&gt;

&lt;h1 id=&quot;근무기록&quot;&gt;근무기록&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;해당 기능은 비즈박스 어플리케이션에서 조회할 수 없음&lt;/strong&gt;&lt;br /&gt;
근무기록을 가져오는 작업은 금방 끝났다. 데이터와 요청 자체가 간단했기 때문이다.&lt;br /&gt;
하지만, 휴가를 쓰게 되면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;휴가&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;출근여부 정상&lt;/code&gt; 두개가 동일한 날에 존재하는 경우가 있다는 것을 추후 유지보수 단계에서 알게 된 부분이 있었는데, 해당 부분은 여유될때 추가적으로 개선해야될 부분이다.&lt;/p&gt;

&lt;h1 id=&quot;식대계산&quot;&gt;식대계산&lt;/h1&gt;
&lt;p&gt;식대는 사내 규칙으로만 존재하며, 비즈박스 앱에서는 제공하지 않는 기능이다.&lt;br /&gt;
식대는 근무기록을 기반으로, 당일 출근하면 7000원. 근무시간이 11시간을 넘어가면 14000원이 되는 방식이다.&lt;br /&gt;
앱 내에서는 계산을 하고 당월 첫째날부터 당일까지 사용 가능한 총 식대를 계산하여 보여준다.&lt;/p&gt;

&lt;h1 id=&quot;휴가-기안&quot;&gt;휴가 기안&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;해당 기능은 비즈박스 어플리케이션에서 사용할 수 없음&lt;/strong&gt;&lt;br /&gt;
휴가 기안에 대한 기능을 앱에 구현할 때 생각보다 시간이 오래 걸렸던 걸로 기억한다.&lt;br /&gt;
그 이유는 여러개의 휴가 목록. 휴가 공유 캘린더 따로 존재. 휴가 기안시 페이지로 넘어갈 때, 휴가 목록에 대한 HTML로 전달하는 부분, 휴가 선택시, 공휴일 혹은 주말여부 자동 제외 등이 있었다.
그리고 휴가를 쓸 때, 결제자를 설정하는데, 해당 설정란을 가져와서 순서를 어떻게 하느냐도 문제였었다.&lt;br /&gt;
어떻게 꾸역꾸역 작업해서 결국 앱 내에 휴가 기안 기능은 포함되었고, 개인적으로 웹에 접속해서 신청하는 것보다 훨씬 편하다고 생각한다.&lt;/p&gt;

&lt;h1 id=&quot;자원-달력&quot;&gt;자원 달력&lt;/h1&gt;
&lt;p&gt;자원 달력은 비즈박스 앱에도 존재하는 기능인데, 회의실/장비같은 자원을 예약하고, 예약 목록을 조회할 수 있는 기능이다.&lt;br /&gt;
해당 부분에 대해서는 비즈박스 앱과 거의 동일하게 옮겨왔는데, 자원에 따라서 따로 당일 예약 여부를 볼 수 있다는 차이점이 존재한다.&lt;/p&gt;

&lt;h1 id=&quot;업데이트-이력-관리-및-배포&quot;&gt;업데이트 이력 관리 및 배포&lt;/h1&gt;
&lt;p&gt;업데이트 이력 관리는 github에 올려둔 파일을 조회하여 이력을 관리하도록 하였다.&lt;br /&gt;
해당 파일에는 버전/업데이트 로그가 존재한다.&lt;br /&gt;
그리고 배포는 사내 앱배포 어플리케이션인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트위니 앱센터&lt;/code&gt;와 회사 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Confluence&lt;/code&gt;를 이용하여 배포하였다.&lt;/p&gt;

&lt;h1 id=&quot;디자인&quot;&gt;디자인&lt;/h1&gt;
&lt;p&gt;앱 디자인은 처음에는 무척 투박했으나, 친하게 지내는 회사 디자이너분께서 근무기록+식대계산을 하는 화면에 대해서만 어느정도 디자인을 해주셨다.&lt;br /&gt;
디자인 당시, 나는 근무기록 + 식대계산을 한 화면에 넣고 싶어했고, 디자이너분꼐서는 두개의 성격이 달라서, 같은 페이지에 있으면 문제가 될 수 있다고 이야기 해주셨었는데, 이야기 끝에 타협하여 지금의 형태가 되었다. ( 솔직히 거의 밀어붙이기만 했었다… )&lt;/p&gt;

&lt;p&gt;실제로, 4월의 경우, 시작이 되는 1일이 월요일이 아니어서 금주의 출근기록을 조회 + 평균근무시간을 보여주는 디자인과 식대를 계산한 디자인이 매치되지 않는 부분이 있다고 느꼈었다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;열심히 만들었고, AOS/IOS/DESKTOP으로 Deploy하여 배포해보았는데, 개인적으로 재밌었고, 사람들이 잘쓰고있다고 너무 좋다고 이야기해주는 것을 보니, 보람찼다.&lt;br /&gt;
그리고 처음으로 디자이너가 준 디자인을 보고 맞춰가면서 작업해봤는데, 어려울거라고는 생각했지만, 생각보다 더 어려웠었다. 하지만, 처음 해보니, 재미도 있었다.&lt;br /&gt;
앱을 만들면서 나는 정리가 잘 안된다를 다시 한 번 느꼈고, 아직도 많이 부족하구나를 다시 한번 느꼈다. 더 정진해야겠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;디자인 도움을 주신 디자이너분께 다시한번 감사합니다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;앱은 추후, 코드를 조금 더 정리한 뒤에 개인 git에 공개할 예정이다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;(휴가 기안시, 대상이되는 캘린더를 임의로 변경할 수 있게 수정하고, 타회사와 맞지 않는 식대계산 부분은 제외할 예정)&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;인앱-사진&quot;&gt;인앱 사진&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;아래에서 자원 예약시, 참여자는 캡처 당시 모바일 환경에서 보이질 않아서 제외함.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;출퇴근기록 / 식대 / 주평균출근시간
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-1.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가신청 목록
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-2.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가신청 화면
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-3.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;결제라인 설정(조회)
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-4.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가신청 화면 (결제라인 설정이후)
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-5.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가 선택 화면
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-6.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가 종류 목록
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-7.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가 선택 화면 ( 종류선택 + 날짜지정 이후 )
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-8.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;휴가 신청화면 ( 상신라인 설정 및 휴가 목록 선택 이후 )
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-9.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 달력
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-10.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 달력 예약 디테일
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-11.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 달력 자원 종류 필터링
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-12.png&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 예약
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-13.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자원 예약 ( 자원 목록 )
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-14.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설정
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-15.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;버전정보 및 업데이트 로그
&lt;img src=&quot;../../../assets/image/twinny_helper/KakaoTalk_Photo_2021-04-10-07-00-16-16.jpeg&quot; alt=&quot;메인&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="Flutter" /><category term="Flutter" /><summary type="html">사내 비즈박스 도입에 따른, TwinnyHelper 앱 제작기</summary></entry><entry><title type="html">푸시 스로틀링</title><link href="https://jihwankim.github.io/moigo/%ED%91%B8%EC%8B%9C-%EC%8A%A4%EB%A1%9C%ED%8B%80%EB%A7%81/" rel="alternate" type="text/html" title="푸시 스로틀링" /><published>2021-04-09T00:00:00+09:00</published><updated>2021-04-09T22:06:00+09:00</updated><id>https://jihwankim.github.io/moigo/%ED%91%B8%EC%8B%9C-%EC%8A%A4%EB%A1%9C%ED%8B%80%EB%A7%81</id><content type="html" xml:base="https://jihwankim.github.io/moigo/%ED%91%B8%EC%8B%9C-%EC%8A%A4%EB%A1%9C%ED%8B%80%EB%A7%81/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;모이고 푸시 스로틀링을 통한 TOPIC_RATE_EXCEEDED 에러 방지&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/concept-options#device_throttling&quot;&gt;단일 기기에 대한 최대 메시지 속도&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://firebase.google.com/docs/cloud-messaging/send-message?hl=ko#admin&quot;&gt;FCM 에러 목록&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;모이고 기능 개발도중 FCM에 TOPIC RATE EXCEEDED 에러가 발생했다.&lt;/p&gt;

&lt;p&gt;해당 에러의 발생 사유는 아래와 같다.&lt;br /&gt;
&lt;strong&gt;특정 주제의 구독자에게 전달되는 메시지 비율이 너무 높습니다. 이 주제로 보내는 메시지 수를 줄이세요. 바로 다시 보내도록 시도해서는 안 됩니다&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;일단, 단일 기기에 대한 최대 메세지 속도 제한을 보고 접근했다.&lt;/p&gt;

&lt;p&gt;문서 상에서 FCM의 클라이언트 수신 가능한 최대 개수가 분당 240개. 시간당 5000개까지 제한하고 있다.&lt;br /&gt;
분당 240개를 잡고 계산했을 때, 0.25초당 1개의 푸시만 클라이언트에 전송되어야 한다.&lt;br /&gt;
물론, 최대로 잡았을 떄 저렇다는 거지, 실제로는 더 적게 보내야 한다.&lt;/p&gt;

&lt;p&gt;당장 보내는 메세지의 수를 많이 줄이는 것은 어렵다고 판단했다.&lt;br /&gt;
따라서, 최근에 해당 부분에 대해서 작업하여, 0.25초마다 한번씩만 푸시를 하도록 하였다.&lt;br /&gt;
여러개의 푸시가 한번에 몰려도 토픽당 1초에 최대 4번까지만 전송한다는 이야기다.&lt;br /&gt;
코드 상에서는 각 토픽마다 gen_server를 global로 띄운후에, 요청 function 을 호출하면, 띄워진 토픽에 해당하는 gen_server로 푸시요청이 넘겨지고, 매 0.25초 마다 한번씩 해당 푸시를 전송하도록 하였다.&lt;/p&gt;

&lt;p&gt;이후, 해당에러는 발생하지 않게 되었다.&lt;/p&gt;

&lt;p&gt;채팅을 제공하고, 여러가지 동작에 대해서 클라이언트간 싱크를 지원하기 위해 각 동작마다 FCM을 전송하고 있기 때문에, 위 방법은 임시조치일 뿐, 해결방법이 되지는 못한다.&lt;br /&gt;
따라서, 지금 생각해본 해결방법은 포그라운드일 경우, WebSocket을 통해 데이터를 받고, 백그라운드일 경우, FCM Notification만 클라이언트에 전송하는 방법이다.&lt;br /&gt;
해당 부분에 대해 개선을 하게 되면, 추후 포스팅을 통해, 문제가 되었던 점과 어떤것을 고민했는지 남길 예정이다.&lt;/p&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="MoiGo" /><summary type="html">모이고 푸시 스로틀링을 통한 TOPIC_RATE_EXCEEDED 에러 방지</summary></entry><entry><title type="html">푸시 시스템 개선</title><link href="https://jihwankim.github.io/moigo/%EB%AA%A8%EC%9D%B4%EA%B3%A0-%ED%91%B8%EC%8B%9C-%EA%B0%9C%EC%84%A0/" rel="alternate" type="text/html" title="푸시 시스템 개선" /><published>2021-04-06T00:00:00+09:00</published><updated>2021-04-06T22:06:00+09:00</updated><id>https://jihwankim.github.io/moigo/%EB%AA%A8%EC%9D%B4%EA%B3%A0-%ED%91%B8%EC%8B%9C-%EA%B0%9C%EC%84%A0</id><content type="html" xml:base="https://jihwankim.github.io/moigo/%EB%AA%A8%EC%9D%B4%EA%B3%A0-%ED%91%B8%EC%8B%9C-%EA%B0%9C%EC%84%A0/">&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;모이고 서버 푸시 개선에 대한 포스팅&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;작성-이유&quot;&gt;작성 이유&lt;/h1&gt;

&lt;p&gt;2019년 트위니에서 회사 시무식에서 이벤트로 모이고 그룹방에서 퀴즈에 대해 정답을 입력하는 이벤트를 진행했다.&lt;br /&gt;
해당 이벤트를 진행하던 도중 모이고 서버가 터지는 일이 발생했다. 심지어 모이고 서버는 Erlang으로 작성되어있다.&lt;br /&gt;
왜 이런 일이 발생한건지, 원인은 무엇이고 어떻게 이것을 개선했는지에 대한 글이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;서버가-왜-터졌는가&quot;&gt;서버가 왜 터졌는가&lt;/h1&gt;

&lt;p&gt;서버가 터졌던 이유중 하나로는 서버가 1대만 떠있었기 때문이다.&lt;br /&gt;
서버가 1대만 떠있던 이유는 당시 모이고 DAU가 매우 적었기 때문에, 비용 절감을 위해 2대 -&amp;gt; 1대로 서버의 수를 줄여놨었다.&lt;br /&gt;
비용절감을 위해서라지만, 1대라면, 해당 서버가 죽어버리면, 바로 장애가 일어나게 된다. 애초에 2~3대를 기본적으로 운용했어야 했는데, 해당 부분은 우리팀의 실수였다.&lt;br /&gt;
이후, 서버는 상시 2대를 기본 운용하도록 변경하였다.&lt;br /&gt;
만약, 2대가 있었다면, 요청분산이 어느정도 될 테니, 서버가 죽진 않았을거라 생각된다.&lt;/p&gt;

&lt;p&gt;서버가 터졌던 가장 큰 이유는 모이고 서버의 푸시 전송 방식이 효율적이지 않아서였다.&lt;br /&gt;
당시 클라이언트별로 데이터 푸시를 따로 보내고, 알람도 따로 보냈다.&lt;br /&gt;
채팅전송시 한명의 유저에게 보내는 푸시는 AOS의 채팅데이터 푸시. IOS 채팅 데이터 푸시. IOS 노티푸시가 있다. (클라이언트 타입별로 따로 보내고 있었다.)&lt;/p&gt;

&lt;p&gt;만약, 그룹으로 채팅을 보낸다면, 개개인에게 푸시를 각자 전송했었고, 만약, 10명이 있는 방이라면 채팅 1개당 전송되는 푸시의 개수는 30개가 된다.&lt;br /&gt;
추가적으로 채팅을 읽었을때도 푸시가 있어서 이런걸 합하면, 50~60명의 유저가 채팅방에 있을 때, 일시에 채팅전송을 시작한다면, 어마어마한 양의 FCM 전송요청이 생긴다.&lt;br /&gt;
간단하게 계산해보면, 채팅 하나당 전송되는 푸시 요청 횟수는 150회가 되는데, 연속적으로 채팅을 전송하게된다면? 생각만해도 끔찍하다.&lt;/p&gt;

&lt;p&gt;요청이 있는것만으로 서버가 죽은 이유는 Erlang에 동시에 떠있는 프로세스 개수가 많아지면서 메모리를 너무 많이 잡아먹어서였다.&lt;br /&gt;
만약, 채팅전송을 한다면, 푸시 자체는 비동기로 전송하기 때문에, 비동기 푸시를 위해 프로세스가 하나 더 뜬다. 이후, 보내야하는 유저별로 데이터 싱크를 위한 저장소에 추가적으로 데이터를 저장하게 된다. 해당 동작도 비동기로 동작한다. 즉 여기서 프로세스가 유저수만큼 뜨게 된다.&lt;br /&gt;
이후, lhttpc library 자체적으로 프로세스를 띄워서 요청했던 것으로 기억하는데, 해당 요청수만큼 다시 프로세스가 뜨고, 추가적으로 몇개의 프로세스가 더 뜨는 것을 확인했었다.&lt;/p&gt;

&lt;p&gt;실제로, 개발서버에 테스트를 해봤었을때, 특정 프로세스가 많이 떠있던것을 확인했는데, ssl 관련 프로세스였던 것으로 기억한다.&lt;/p&gt;

&lt;p&gt;위 과정을 거쳐 프로세스가 비정상적으로 많이 떠있게 되며, 메모리가 가득차게 되어 서버가 죽어버렸다.&lt;/p&gt;

&lt;p&gt;그렇다면 해당 푸시를 어떻게 최적화를 시켜야할까? 라는 고민은 이전부터 있었다.&lt;br /&gt;
해당 현상에 대해 어느정도 예상했었고, 당시 사수형과 이야기해서 해당 부분에 대해 나중에 개선하자고 이야기가 되어있었다.&lt;/p&gt;

&lt;p&gt;시무식 당시에 이러한 이유로 서버가 죽어버리자, 푸시 전송방식을 개선하였다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;푸시-방식-개선-여정&quot;&gt;푸시 방식 개선 여정&lt;/h1&gt;

&lt;p&gt;푸시 개선은 결과적으로 보면 아래와 같이 바뀌었다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;개선이전&lt;/th&gt;
      &lt;th&gt;개선이후&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;토픽&lt;/td&gt;
      &lt;td&gt;유저토픽&lt;/td&gt;
      &lt;td&gt;유저토픽 + 그룹토픽 (그룹단위 토픽)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;푸시방식&lt;/td&gt;
      &lt;td&gt;모든 유저에게 각자의 토픽에 대해 푸시&lt;/td&gt;
      &lt;td&gt;유저 대상으로는 이전과 동일한 방식으로 푸시. 하지만, 그룹이 대상이라면, 그룹 토픽으로 푸시&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;개선 이전 방법에서 개선 이후 방식으로 곧바로 넘어가게 되면 업데이트되지 않은 클라이언트들이 정상동작하지 않게 될것이고, 그렇다고 그대로 두면 서버가 또 터지는 일이 발생할테니, 양쪽을 모두 사용할 수 있는 방식으로 개선되었다.&lt;/p&gt;

&lt;p&gt;일단, 푸시 데이터 종류에 따라, 우선순위를 지정을 하고, 우선순위에 따라 높은 우선순위의 아이템부터 유저에게 푸시하였다.&lt;br /&gt;
각 우선순위에 따라, AWS SQS에 push하고, 우선순위가 높은 큐에서부터 pull을 하여 우선 푸시하는 방법을 사용하였다.&lt;br /&gt;
우선순위가 높은 것들에는 채팅, 그룹원변경 등이 었었고, 낮은 운선순위의 것들은 채팅읽음 동기화 푸시 등이 있다.&lt;/p&gt;

&lt;p&gt;그리고 여러개의 토픽에 대해서 묶어서 한번에 푸시할 수 있도록 FCM 요청도 개선되었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ( ex condition : ~~ in topics || ~~ in topics)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 작업을 하고 난 이후에는 동일한 이유로 서버가 터지는 일은 없었다.&lt;/p&gt;

&lt;p&gt;이후, 클라이언트가 업데이트를 어느정도 하였고, 개선버전 푸시 시스템으로 넘어가도 문제가 없는 시기가 되었다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;푸시-개선-적용&quot;&gt;푸시 개선 적용&lt;/h2&gt;

&lt;p&gt;실제로 개선버전 푸시 방식을 적용하기 전, 클라이언트에 알람을 보내는 부분에서 문제가 발생하였다.&lt;br /&gt;
IOS의 경우, 백그라운드 동작을 할 수가 없어서 알람을 서버에서 직접 쏘는데, 유저 설정에 따라 알람을 받지 않기도 하고, 친구의 이름 설정에 따라, 알람이 다르게 와야 한다.&lt;br /&gt;
하지만, 코드 상에서는 대상 토픽을 대상으로 알람을 쏘고 있었기 때문에, 알람이 원하던 것과 다르게 전송되고 있었다.&lt;br /&gt;
따라서, 유저별로 알람을 따로 보내게끔 추가로 개선해야 했었다.&lt;/p&gt;

&lt;p&gt;해당 부분에 대해 어떻게 해결할까 고민하며 서칭하던 중에 FCM 기능중 Multicast기능이 있고, 해당 기능이 알람을 보낼때 아주 적합하다고 생각했다.&lt;/p&gt;

&lt;p&gt;그룹 알람의 경우, 알람을 꺼놓지 않은 유저들에 대한 정보만 가져와서 해당 유저들에게만 Notification을 푸시하도록 수정하였다.&lt;br /&gt;
개인 대상으로 전송해야 할 때는 차이가 없었지만, 그룹에서 여러명의 유저에게 한번에 묶어서 보낸다는 것은 대단히 큰 이점이라고 생각한다.&lt;br /&gt;
Notification에는 Multicast기능을 이용하여 푸시하도록 개선하였다.&lt;/p&gt;

&lt;p&gt;또, 각 클라이언트 타입별로 메세지를 따로 보내고 있었는데, 현재 모이고에서 사용되고 있는 메세지 body는 IOS/ANDROID를 따로 보낼 필요가 없어서 하나로 통합하여 보내도록 개선하였다.&lt;/p&gt;

&lt;p&gt;개선이 모두 이루어 지고 나서, 너무나도 느렸던 모이고의 푸시 속도는 놀라울 정도로 개선되었다.&lt;/p&gt;

&lt;p&gt;많은 부분이 좋아지고 있지만, 갈길은 여전히 멀다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;추가적으로 해당 작업도중 HTTP v1이 출시된 것을 알고 버전을 올리려고 했으나, 버그가 발생하여 올리지 못했다. 해당 부분에 대해서는 추후에 따로 포스팅해볼 예정이다.&lt;/p&gt;</content><author><name>Jihwan Kim</name><email>jihwan.dev@gmail.com</email></author><category term="MoiGo" /><summary type="html">모이고 서버 푸시 개선에 대한 포스팅</summary></entry></feed>